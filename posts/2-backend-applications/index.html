<!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <link rel="icon" href="/blog/assets/favicon.png" type="image/x-icon">
            <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap">
            <link rel="stylesheet" href="/blog/css/styles.css">
            <title>The rose and the thorns, how I use to create my backend applications</title>
            <base href="/blog">
        </head>
        <body>
            <nav>
    <a href="/blog/" class="">Home</a>
    <a href="/blog/cv" class="">CV</a>
    <a href="/blog/projects" class="">Projects</a>
    <a href="/blog/posts" class="">Blog</a>
</nav>
            <header>
                <h1>The rose and the thorns, how I use to create my backend applications</h1>
            </header>
            <main>
                <p>[Work In Progress]</p>
<h2>Backend applications with Spring: a recurring solution to a recurring problem</h2>
<p>Developing a REST API Backend application is one of the most frequent task a developer needs to do.
From San Francisco to Melbourne, every day some developer, somewhere, needs to set up a backend application serving some REST endpoints.</p>
<p>One of the most popular tools to get this job done is building a Spring Boot application and shipping the docker container to some deployment service.</p>
<p>During the last years I was exposed to different way to create a Spring Boot application and I decided to try to gather most of the tools I used
and the best practices in a blog post. I would like this to be primarily a retrospective of what I learned on the subject, but I would be happy if it also ends up helping somebody else.</p>
<p>When I need to create a Backend application, I tend to think about it as a two-sided problem to solve.</p>
<ol>
<li>Implementing the requested business logic (and this is trivial)</li>
<li>Correctly configuring the Spring Boot application and all the ancillary job required (containers, integration tests, ...)</li>
</ol>
<p>During the years I came to imagine a well-configured Back-end application as a Rose with (many) thorns.</p>
<ul>
<li>The <strong>rose</strong> is the part meaningful for the business in all its beauty: Using the Design Patterns to be actually able to translate in code the business domain and logic.</li>
<li>The <strong>thorn</strong> is the heinous part: the effort necessary to configure and spin up the application, making it maintainable, containerized, testable and shippable.</li>
</ul>
<p>I need to say in advance, that this is a rather subjective view that I matured through the years, being exposed early in my career to Spring Applications that were already &quot;ready to work on&quot; and only
later to the problem of setting them up from scratch, increasing the scope of the problem from the simple coding to the actual configuration and deployment of the application.
From this experience I came to the conclusion that while there is a lot of literature on the &quot;rose&quot; part, the &quot;thorns&quot; are often overlooked, and they might actually be the most difficult aspect of the actual application.</p>
<h2>The thorns</h2>
<p>One of the reasons I find difficult to initially set up a functioning Spring Boot application is the lack of constraints in the beginning.
This is clearly not an issue of Spring, but actually a reason for its extensive success: being agnostic to the way the app is going to be deployed.
While the older Spring MVC produced only WARs and precluded some deployment techniques, Spring comes with an embedded Tomcat server and builds a handy .jar file, which opens the developer to many other options for deployment.</p>
<p>But how to avoid staring at a blank page? How to overcome the lack of constraints that come from Spring?
Something that helps is to think about the operational problems that, as a developer, I would like to solve:</p>
<ul>
<li>Which Profiles do I need? What will be different between deploying the application locally and on production?</li>
<li>How can I avoid the &quot;It works on my machine&quot; scenarios? How can I create a resilient and machine-agnostic application?</li>
<li>How do I manage the dependencies? Is there the need for some particular toolchain?</li>
<li>How does the backend application integrate with the other systems that are already existing? Does it communicate with something else? Does it do synchronously or asynchronously?</li>
<li>How frequently will I need to change the DB structure on production?</li>
<li>How do I setup an integration test to be sure that the whole application runs properly?</li>
</ul>

            </main>
        </body>
        <script>
            document.addEventListener("DOMContentLoaded", () => {
                document.querySelectorAll('a[href^="#"]').forEach(anchor => {
                    // Exclude links starting with a number and a hyphen
                    if (!/^\d+-/.test(anchor.getAttribute("href").substring(1))) {
                        anchor.addEventListener("click", function(e) {
                            e.preventDefault();
                            const targetId = this.getAttribute("href").substring(1); // Remove the '#' from the href
                            const target = document.getElementById(targetId);
                            if (target) {
                                const headerOffset = 70; // Adjust this value based on your fixed header height
                                const elementPosition = target.getBoundingClientRect().top;
                                const offsetPosition = elementPosition + window.scrollY - headerOffset;

                                window.scrollTo({
                                    top: offsetPosition,
                                    behavior: "smooth"
                                });
                            }
                        });
                    }
                });
            });
        </script>
        </html>